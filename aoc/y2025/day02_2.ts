import AbstractRiddle from '../../src/JS/AbstractRiddle';

class Y2025_Day02_1 extends AbstractRiddle {

    riddle: string = "What do you get if you add up all of the invalid IDs using these new rules?";

    run(input: string[]): number {

        // 1. Parse input
        const ranges = input[0].split(",").map(
            s => s.split('-',2));

        let sum = 0;
        let checked = 0;
        let found = 0;

        for (const range of ranges) {
            const [fromS, toS] = range;
            const from = parseInt(fromS);
            const to = parseInt(toS);

            const minLength = fromS.length;
            const maxLength = toS.length;

            // check for all repeated numbers, if they lie in the range
            // the pattern of these numbers is: can be split into multiple equal parts
            for(let strLen = minLength; strLen <= maxLength; strLen++) {
                const dividers = this.findIntegerDividers(strLen);

                // make sure we check every number only once (e.g. 3*"22" and 2*"222" is the same!)
                let checkedNumbers = new Set<number>();

                for (const divider of dividers) {
                    const partLength = strLen / divider;

                    // generate strings of the length of this path
                    this.generateNumberStrings("", partLength, (str): boolean => {
                        // @ts-ignore
                        const num = parseInt(str.repeat(divider));
                        if (checkedNumbers.has(num)) {
                            return false;
                        }
                        checkedNumbers.add(num);

                        checked++;
                        if (num >= from && num <= to) {
                            sum += num;
                            found++;
                        }
                        return num > to;
                    });
                }
            }
        }

        return sum;
    }

    /**
     *
     * @param current           The current string that was generated by preceding recursive calls
     * @param targetLength      The required length of the generated number string
     * @param callback          Handle the generated number and return true if the number generation should cancel
     */
    generateNumberStrings(
        current: string,
        targetLength: number,
        callback: {(s: string): boolean}
    ): boolean {
        if (current.length >= targetLength) {
            return callback(current);
        }

        // we cant have leading zeros
        const startValue = current === '' ? 1 : 0;
        for (let i = startValue; i <= 9; i++) {
            const shouldBreak = this.generateNumberStrings(current + i, targetLength, callback);
            if (shouldBreak) {
                return true;
            }
        }

        return false;
    }

    findIntegerDividers(num: number): number[] {
        const dividers = [];
        // ignore the division by one, as we are searching repetitions of length >= 2
        for (let div = 2; div <= num; div++) {
            if ((num % div) === 0) {
                dividers.push(div);
            }
        }
        return dividers;
    }
}

// noinspection JSUnusedGlobalSymbols
export default (new Y2025_Day02_1());